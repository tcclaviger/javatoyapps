package trees.nodes;

/**
 * A binary search tree node that stores int values.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class Node
{
    /*
        Note: This is breaking encapsulation, but we
        will keep our fields public to write code that
        is similar to what we see when the node class
        is an inner-class.
     */
    public int data;
    public Node left;
    public Node right;

    /**
     * Constructs a node with a new element.
     *
     * @param data the new data element
     */
    public Node(int data)
    {
        this.data = data;
    }

    /**
     * Constructs a node with a new element and
     * reference to the left and right node in the tree.
     *
     * @param data the new data element
     * @param left the reference to the left child
     * @param right the reference to the right child
     */
    public Node(int data, Node left, Node right)
    {
        this.data = data;
        this.left = left;
        this.right = right;
    }

    public StringBuilder toString(StringBuilder prefix, boolean isTail, StringBuilder builder)
    {
        if(right!=null)
        {
            right.toString(new StringBuilder().append(prefix).append(isTail ? "│   " : "    "), false, builder);
        }

        builder.append(prefix).append(isTail ? "└── " : "┌── ").append(data).append("\n");

        if(left!=null)
        {
            left.toString(new StringBuilder().append(prefix).append(isTail ? "    " : "│   "), true, builder);
        }

        return builder;
    }

    /**
     * Builds a visualization of the tree on the Java console.
     *
     * @see https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram-in-java/8948691#8948691
     * @return a diagram of the tree
     */
    @Override
    public String toString()
    {
        return toString(new StringBuilder(), true, new StringBuilder()).toString();
    }
}
